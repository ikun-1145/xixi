<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>小游戏</title>
  <style>
    body { margin: 0; overflow: hidden; background: #71f8fc; }
    canvas { display: block; margin: auto; background: url('p/bg.png') center / cover no-repeat; }
    #restartBtn {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      padding: 12px 24px; font-size: 20px; border: none;
      border-radius: 12px; background: #a0fff8; cursor: pointer;
      display: none;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<button id="restartBtn">重新开始</button>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const BASE_WIDTH = 400;
const BASE_HEIGHT = 600;

let bird = { x: 50, y: 250, w: 30, h: 30, gravity: 0.6, vel: 0 };
let pipes = [];
let score = 0;
let gameOver = false;
const restartBtn = document.getElementById('restartBtn');
const PIPE_SPACING = 450; // 前后管子真实间距

// 自适应屏幕
function resizeCanvas() {
  const aspectRatio = BASE_WIDTH / BASE_HEIGHT;
  let w = window.innerWidth;
  let h = window.innerHeight;
  if (w / h > aspectRatio) {
    w = h * aspectRatio;
  } else {
    h = w / aspectRatio;
  }
  canvas.width = w;
  canvas.height = h;
}
window.addEventListener('load', resizeCanvas);
window.addEventListener('resize', resizeCanvas);

// 缩放函数
function scaleX(x) { return x * canvas.width / BASE_WIDTH; }
function scaleY(y) { return y * canvas.height / BASE_HEIGHT; }
function scaleW(w) { return w * canvas.width / BASE_WIDTH; }
function scaleH(h) { return h * canvas.height / BASE_HEIGHT; }

// 生成管子
function spawnPipe() {
  let top = Math.random() * 200 + 50;
  let gap = 180; // 管子间隙
  pipes.push({ x: BASE_WIDTH, w: 50, top: top, bottom: BASE_HEIGHT - top - gap, passed: false });
}

// 重置游戏
function resetGame() {
  bird.y = 250;
  bird.vel = 0;
  pipes = [];
  score = 0;
  gameOver = false;
  restartBtn.style.display = 'none';
  loop();
}

// 控制
document.addEventListener('keydown', e => { if(e.code==='Space') bird.vel = -6; });
document.addEventListener('mousedown', () => { bird.vel = -6; });

// 更新逻辑
function update() {
  bird.vel += bird.gravity;
  bird.y += bird.vel;

  if (bird.y + bird.h > BASE_HEIGHT || bird.y < 0) gameOver = true;

  // 管子生成条件：确保前后间距
  if (pipes.length === 0 || (BASE_WIDTH - pipes[pipes.length-1].x) >= PIPE_SPACING) {
    spawnPipe();
  }

  pipes.forEach(pipe => {
    pipe.x -= 2;
    if (!pipe.passed && bird.x > pipe.x + pipe.w) {
      score++;
      pipe.passed = true;
    }
    if (bird.x < pipe.x + pipe.w && bird.x + bird.w > pipe.x &&
        (bird.y < pipe.top || bird.y + bird.h > BASE_HEIGHT - pipe.bottom)) {
      gameOver = true;
    }
  });

  pipes = pipes.filter(p => p.x + p.w > 0);
}

// 绘制
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 小鸟
  ctx.fillStyle = 'blue';
  ctx.fillRect(scaleX(bird.x), scaleY(bird.y), scaleW(bird.w), scaleH(bird.h));

  // 管子
  ctx.fillStyle = 'green';
  pipes.forEach(pipe => {
    ctx.fillRect(scaleX(pipe.x), 0, scaleW(pipe.w), scaleY(pipe.top));
    ctx.fillRect(scaleX(pipe.x), canvas.height - scaleY(pipe.bottom), scaleW(pipe.w), scaleY(pipe.bottom));
  });

  // 分数
  ctx.fillStyle = 'white';
  ctx.font = `${24 * canvas.width / BASE_WIDTH}px Arial`;
  ctx.fillText('得分: ' + score, scaleX(10), scaleY(30));
}

// 游戏循环
function loop() {
  if(gameOver){
    restartBtn.style.display = 'block';
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = 'white';
    ctx.font = `${36 * canvas.width / BASE_WIDTH}px Arial`;
    ctx.fillText('游戏结束', scaleX(100), scaleY(300));
    ctx.fillText('得分: '+score, scaleX(120), scaleY(350));
    return;
  }
  update();
  draw();
  requestAnimationFrame(loop);
}

// 重玩按钮
restartBtn.addEventListener('click', resetGame);

loop();
</script>
</body>
</html>