<!DOCTYPE html>
<html lang="zh-Hans">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>小游戏</title>

<link rel="preload" as="image" href="p/chengshi.webp" type="image/webp">
<link rel="preload" as="image" href="p/chengshi.png">

<style>
*{box-sizing:border-box;margin:0;padding:0}
body{
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","PingFang SC",
  "Microsoft YaHei",Arial,sans-serif;
  background:url("p/chengshi.png") center/cover no-repeat #87CEEB;
  min-height:100vh;
  display:flex;
  justify-content:center;
  align-items:flex-start;
  user-select:none;
  -webkit-tap-highlight-color:transparent;
  /* iOS Safari 高度修复 */
  min-height: 100svh;
}
@supports (background-image: url("p/chengshi.webp")) {
  body {
    background:url("p/chengshi.webp") center/cover no-repeat #87CEEB;
  }
}

#gameWrapper{
  position:relative;
  margin:2vh auto;
  display:flex;
  justify-content:center;
}
canvas{
  border-radius:12px;
  box-shadow:0 10px 20px rgba(0,0,0,.25);
}

.overlay{
  position:absolute;
  inset:0;
  display:none;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  gap:16px;
  background:rgba(0,0,0,.35);
}

.overlay h1{
  color:#fff;
  font-size:48px;
  text-shadow:2px 2px 0 #000;
}

.overlay button{
  padding:.8rem 2.2rem;
  font-size:1.2rem;
  font-weight:700;
  border-radius:30px;
  border:2px solid #fff;
  background:linear-gradient(#71f8fc,#40e0d0);
  color:#004d4d;
}

/* ================= 横屏 UI + iOS 安全区 ================= */

/* 默认按钮样式（竖屏） */
.overlay button{
  margin-top: 12px;
}

/* 横屏时：按钮移动到右侧中部 */
@media (orientation: landscape) and (max-width: 900px) {
  #gameWrapper{
    align-items: center;
  }

  .overlay{
    flex-direction: row;
    justify-content: center;
    gap: 24px;
  }

  .overlay h1{
    font-size: 36px;
  }

  .overlay button{
    font-size: 1.1rem;
    padding: .7rem 1.8rem;
  }
}

/* iOS 底部安全区（Home Indicator） */
@supports (padding: env(safe-area-inset-bottom)) {
  body{
    padding-bottom: env(safe-area-inset-bottom);
  }

  .overlay{
    padding-bottom: env(safe-area-inset-bottom);
  }
}
</style>
</head>

<body>
<div id="gameWrapper">
  <canvas id="game"></canvas>

  <div class="overlay" id="overlay">
    <h1 id="overText">游戏结束</h1>
    <button id="restart">再来一局</button>
  </div>
</div>

<script>
const i18n = {
  zh: {
    title: "小游戏",
    gameOver: "游戏结束",
    restart: "再来一局"
  },
  en: {
    title: "Mini Game",
    gameOver: "Game Over",
    restart: "Play Again"
  },
  ja: {
    title: "ミニゲーム",
    gameOver: "ゲームオーバー",
    restart: "もう一度"
  }
};
function detectLang(){
  const saved = localStorage.getItem("lang");
  if (saved && i18n[saved]) return saved;

  const nav = navigator.language || "zh";
  if (nav.startsWith("ja")) return "ja";
  if (nav.startsWith("en")) return "en";
  return "zh";
}

const LANG = detectLang();
const T = i18n[LANG] || i18n.zh;
document.title = T.title;
document.getElementById("overText").textContent = T.gameOver;
document.getElementById("restart").textContent = T.restart;
/* ================= 基础配置 ================= */
const LOGIC_W = 400;
const LOGIC_H = 650;

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const overlay = document.getElementById("overlay");
const restartBtn = document.getElementById("restart");

/* ================= 自适应 ================= */
let scale = 1;

function resize(){
  const dpr = window.devicePixelRatio || 1;

  const availableW = window.innerWidth;
  const availableH = window.innerHeight * 0.95;

  // ====== 填满屏幕（cover 风格，而不是 contain）======
  // 目标：宁可裁一点背景，也不要只占中间一小块
  let widthBased = availableW / LOGIC_W;
  let heightBased = availableH / LOGIC_H;

  // 取较大的那个，优先填满屏幕
  scale = Math.max(widthBased, heightBased);

  // 给一个上限，防止在超大屏幕上无限放大
  scale = Math.min(scale, 2.0);

  // CSS 显示尺寸
  canvas.style.width = LOGIC_W * scale + "px";
  canvas.style.height = LOGIC_H * scale + "px";

  // 实际像素尺寸（乘 DPR，保证高清）
  canvas.width = Math.round(LOGIC_W * scale * dpr);
  canvas.height = Math.round(LOGIC_H * scale * dpr);

  // 每次 resize 都重置坐标系，避免 scale 叠加
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(scale * dpr, scale * dpr);
}
window.addEventListener("resize", resize);
resize();

/* ================= 资源 ================= */
const birdImg = new Image();
birdImg.src = "p/bird.png";

/* ================= 游戏状态 ================= */
let player, pipes, score, highScore, gameOver, rafId;

const gravity = 0.30;
const jumpForce = -5.2;
const pipeGap = 170;
const pipeWidth = 65;
const pipeSpacing = 240;
const pipeSpeed = 2.8;

highScore = Number(localStorage.getItem("highScore")) || 0;

/* ================= 初始化 ================= */
function resetGame(){
  player = { x:60, y:300, size:34, dy:0, angle:0 };
  pipes = [];
  score = 0;
  gameOver = false;
  overlay.style.display = "none";

  for(let i=0;i<2;i++){
    createPipe(LOGIC_W + 100 + i * pipeSpacing);
  }

  cancelAnimationFrame(rafId);
  rafId = requestAnimationFrame(loop);
}

/* ================= 管道 ================= */
function createPipe(x){
  const min = 50;
  const max = LOGIC_H - pipeGap - 120;
  const top = Math.random() * (max - min) + min;

  pipes.push({ x, top, passed:false });
}

/* ================= 碰撞 ================= */
function hit(a,b){
  const pad = 4;
  return !(
    a.x+a.w-pad < b.x ||
    a.x+pad > b.x+b.w ||
    a.y+a.h-pad < b.y ||
    a.y+pad > b.y+b.h
  );
}

/* ================= 更新 ================= */
function update(){
  player.dy += gravity;
  if(player.dy > 12) player.dy = 12;
  player.y += player.dy;

  if(pipes[pipes.length-1].x < LOGIC_W - pipeSpacing){
    createPipe(LOGIC_W + 50);
  }

  pipes.forEach(p=>p.x -= pipeSpeed);
  pipes = pipes.filter(p=>p.x + pipeWidth > -100);

  const birdBox = { x:player.x,y:player.y,w:player.size,h:player.size };

  for(const p of pipes){
    const topBox = { x:p.x,y:0,w:pipeWidth,h:p.top };
    const botBox = {
      x:p.x,
      y:p.top+pipeGap,
      w:pipeWidth,
      h:LOGIC_H-(p.top+pipeGap)
    };

    if(hit(birdBox,topBox) || hit(birdBox,botBox)){
      endGame();
    }

    if(!p.passed && player.x+player.size/2 > p.x+pipeWidth/2){
      score++;
      p.passed = true;
    }
  }

  if(player.y + player.size > LOGIC_H-10 || player.y < -player.size){
    endGame();
  }

  player.angle = Math.max(-0.35, Math.min(Math.PI/2, player.dy*0.12));
}

/* ================= 绘制 ================= */
function draw(){
  ctx.setTransform(scale,0,0,scale,0,0);
  ctx.clearRect(0,0,canvas.width/scale,canvas.height/scale);

  // 管道
  ctx.fillStyle="#5cb85c";
  pipes.forEach(p=>{
    ctx.fillRect(p.x,0,pipeWidth,p.top);
    ctx.fillRect(
      p.x,
      p.top+pipeGap,
      pipeWidth,
      LOGIC_H-(p.top+pipeGap)
    );
  });

  // 鸟
  ctx.save();
  ctx.translate(player.x+player.size/2,player.y+player.size/2);
  ctx.rotate(player.angle);

  if(birdImg.complete){
    ctx.drawImage(birdImg,-player.size/2,-player.size/2,player.size,player.size);
  }else{
    ctx.fillStyle="#ffcc00";
    ctx.fillRect(-player.size/2,-player.size/2,player.size,player.size);
  }
  ctx.restore();

  // 分数
  ctx.fillStyle="#fff";
  ctx.font="900 42px sans-serif";
  ctx.textAlign="center";
  ctx.fillText(score,LOGIC_W/2,60);
}

/* ================= 主循环 ================= */
function loop(){
  update();
  draw();
  if(!gameOver) rafId = requestAnimationFrame(loop);
}

/* ================= 结束 ================= */
function endGame(){
  if(gameOver) return;
  gameOver = true;

  highScore = Math.max(highScore, score);
  localStorage.setItem("highScore", highScore);

  overlay.style.display = "flex";
}

/* ================= 输入 ================= */
function jump(e){
  if(e?.code==="Space") e.preventDefault();
  if(!gameOver) player.dy = jumpForce;
}
document.addEventListener("keydown", jump);
document.addEventListener("mousedown", jump);
document.addEventListener("touchstart", jump, {passive:false});

restartBtn.onclick = e=>{
  e.stopPropagation();
  resetGame();
};

/* ================= 启动 ================= */
birdImg.onload = resetGame;
setTimeout(resetGame,200); // 兜底

/* ================= iOS Safari 特殊适配 ================= */
if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
  document.body.addEventListener("touchmove", e => {
    if (e.target === canvas) e.preventDefault();
  }, { passive:false });

  // 强制重新计算尺寸（解决横竖屏切换高度不准）
  window.addEventListener("orientationchange", () => {
    setTimeout(resize, 300);
  });
}
</script>
</body>
</html>