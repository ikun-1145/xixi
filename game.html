<!DOCTYPE html>
<html lang="zh-Hans">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>小游戏</title>
<link href="https://fonts.googleapis.com/css2?family=Product+Sans&display=swap" rel="stylesheet">
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  body{
    font-family:'Product Sans',sans-serif;
    background: url('p/chengshi.png') center center / cover no-repeat fixed;
    display:flex;flex-direction:column;align-items:center;
    min-height:100vh;color:#1A1A1A;overflow:hidden;
  }

  #gameWrapper{
    position: relative;
    display: inline-block;
  }

  #gameCanvas{
    display:block;
    background: transparent;
    border-radius:12px;
    image-rendering: pixelated;
  }

  .overlay{
    display: none;
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    z-index: 20;
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    pointer-events: none;
  }
  .overlay .buttons { pointer-events: auto; }

  .gameoverText{
    color: #fff;
    font-weight: bold;
    text-align: center;
    text-shadow: 2px 2px 6px rgba(0,0,0,0.6);
    font-size: clamp(20px, 6vw, 48px);
    margin-bottom: 0.4rem;
  }

  .buttons{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap: 0.6rem;
  }
  .buttons button,.buttons a{
    padding:.8rem 1.5rem;
    background:linear-gradient(to right,#71f8fc,#a0fff8);
    border-radius:30px;color:black;font-weight:bold;font-size:1.1rem;border:none;cursor:pointer;margin:.2rem 0;
    text-decoration:none;
  }

  @media (max-width:480px){
    .buttons button, .buttons a { font-size: 1rem; padding: 0.7rem 1.1rem; }
  }
</style>
</head>
<body>
  <div id="gameWrapper">
    <canvas id="gameCanvas"></canvas>

    <!-- 游戏结束遮罩 -->
    <div class="overlay" id="gameOverlay">
      <div class="gameoverText">游戏结束</div>
      <div class="buttons" id="buttonsContainer">
        <button id="restartBtn">重新开始</button>
        <a id="homeLink" href="index.html">返回主页</a>
      </div>
    </div>
  </div>

<script>
/* --------- 初始化与自适应 --------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: true });
const overlay = document.getElementById('gameOverlay');

const LOGIC_WIDTH = 400;
const LOGIC_HEIGHT = 650;
let scale = 1;

function resizeCanvas(){
  const scaleX = window.innerWidth / LOGIC_WIDTH;
  const scaleY = window.innerHeight / LOGIC_HEIGHT;
  scale = Math.min(scaleX, scaleY);
  canvas.width = Math.round(LOGIC_WIDTH * scale);
  canvas.height = Math.round(LOGIC_HEIGHT * scale);
  const wrapper = document.getElementById('gameWrapper');
  wrapper.style.width = canvas.width + 'px';
  wrapper.style.height = canvas.height + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* 加载小鸟图片 */
const birdImg = new Image();
birdImg.src = 'p/bird.png';

/* --------- 游戏变量 --------- */
let player = { x:50, y:250, size:30, dy:0, angle:0 };
let gravity = 0.3;
let jump = -6;
let pipes = [];
let pipeWidth = 60;
let pipeGap = 180;
let pipeSpacing = 250;
let score = 0;
let gameOver = false;
let animationId;
let collisionType = null;  // "top" | "bottom" | "side"

/* 最高分 */
let highScore = parseInt(localStorage.getItem('highScore')) || 0;
function updateHighScore(){ 
  if(score > highScore){ 
    highScore = score; 
    localStorage.setItem('highScore', highScore); 
  } 
}

/* 创建管道 */
function createPipeAt(x){ 
  const topHeight = Math.floor(Math.random() * (LOGIC_HEIGHT - pipeGap - 50)) + 25; 
  pipes.push({ 
    x, topHeight, passed:false,
    get topRect(){ return {x:this.x, y:0, w:pipeWidth, h:this.topHeight}; },
    get bottomRect(){ return {x:this.x, y:this.topHeight+pipeGap, w:pipeWidth, h:LOGIC_HEIGHT-(this.topHeight+pipeGap)}; }
  }); 
}

/* 碰撞检测 */
function rectsCollide(r1,r2){
  return !(r1.x+r1.w < r2.x || r1.x > r2.x+r2.w || r1.y+r1.h < r2.y || r1.y > r2.y+r2.h);
}

/* 重置游戏 */
function resetGame(){
  player = { x:50, y:250, size:30, dy:0, angle:0 };
  pipes = [];
  score = 0;
  gameOver = false;
  collisionType = null;
  overlay.style.display = 'none';
  cancelAnimationFrame(animationId);
  for(let i=0;i<3;i++) createPipeAt(LOGIC_WIDTH + i * pipeSpacing);
  animate();
}

/* 绘制 */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.scale(scale, scale);

  if(gameOver){
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(0,0,LOGIC_WIDTH,LOGIC_HEIGHT);
  }

  // 管道
  ctx.fillStyle = '#2b7a78';
  for(const p of pipes){
    ctx.fillRect(p.x, 0, pipeWidth, p.topHeight);
    ctx.fillRect(p.x, p.topHeight + pipeGap, pipeWidth, LOGIC_HEIGHT - (p.topHeight + pipeGap));
  }

  // 玩家（旋转）
  ctx.save();
  ctx.translate(player.x + player.size/2, player.y + player.size/2);
  ctx.rotate(player.angle);
  if(birdImg.complete){
    ctx.drawImage(birdImg, -player.size/2, -player.size/2, player.size, player.size);
  } else {
    ctx.fillStyle = '#ffcc00';
    ctx.fillRect(-player.size/2, -player.size/2, player.size, player.size);
  }
  ctx.restore();

  // 分数
  const fontSize = Math.max(12, Math.floor(LOGIC_WIDTH * 0.05));
  ctx.fillStyle = '#1A1A1A';
  ctx.font = `${fontSize}px Product Sans`;
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillText(`分数: ${score}`, LOGIC_WIDTH * 0.02, LOGIC_HEIGHT * 0.02);
  ctx.fillText(`最高分: ${highScore}`, LOGIC_WIDTH * 0.02, LOGIC_HEIGHT * 0.12);

  ctx.restore();
}

/* 更新逻辑 */
function update(){
  if(gameOver) return;
  player.dy += gravity;
  player.y += player.dy;

  // 生成管道
  if(pipes.length === 0 || (pipes[pipes.length-1].x < LOGIC_WIDTH - pipeSpacing)){
    createPipeAt(LOGIC_WIDTH);
  }
  for(const p of pipes) p.x -= 2;
  pipes = pipes.filter(p => p.x + pipeWidth > 0);

  // 玩家碰撞箱
  const birdRect = {x:player.x, y:player.y, w:player.size, h:player.size};

  for(const p of pipes){
    if(rectsCollide(birdRect, p.topRect)){
      collisionType = (player.dy > 0) ? "top" : "side";
      endGame();
    }
    if(rectsCollide(birdRect, p.bottomRect)){
      collisionType = (player.dy < 0) ? "bottom" : "side";
      endGame();
    }
    if(!p.passed && player.x > p.x + pipeWidth){
      score++; p.passed = true;
    }
  }

  // 碰到边界
  if(player.y + player.size > LOGIC_HEIGHT){
    collisionType = "bottom";
    endGame();
  }
  if(player.y < 0){
    collisionType = "top";
    endGame();
  }
}

/* 动画循环 */
function animate(){
  update();
  draw();
  if(!gameOver){
    animationId = requestAnimationFrame(animate);
  }
}

/* 死亡动画 */
function endGame(){
  if(gameOver) return;
  gameOver = true;

  function deathAnimation(){
    player.dy += gravity;
    player.y += player.dy;

    // 碰撞方向特效
    if(collisionType === "top"){
      player.angle -= 0.08;
    } else if(collisionType === "bottom"){
      player.angle += 0.15;
    } else if(collisionType === "side"){
      player.x -= 1;
      player.angle += 0.1;
    }

    draw();
    if(player.y < LOGIC_HEIGHT - player.size){
      requestAnimationFrame(deathAnimation);
    } else {
      player.y = LOGIC_HEIGHT - player.size;
      updateHighScore();
      overlay.style.display = 'flex';
    }
  }
  deathAnimation();
}

/* 事件 */
document.addEventListener('keydown', e => { if(e.code === 'Space' && !gameOver) player.dy = jump; });
document.addEventListener('click', () => { if(!gameOver) player.dy = jump; });
document.getElementById('restartBtn').addEventListener('click', resetGame);

/* 启动 */
resetGame();
</script>
</body>
</html>